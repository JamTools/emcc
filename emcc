#!/usr/bin/env bash

#-----------------------------------------------------------------------#
# to be able to exit entire program from within function

trap "exit 1" TERM
export TOP_PID=$$

#-----------------------------------------------------------------------#
# prints script name, warns about changes, prompts for input to continue

startupWarning () {
  echo -e "\nEvolving Music Collection Cleanup (emcc):"
  echo -e "Directory: $rootPath\n"
  echo -e "This script moves, renames, edits files within this directory.\n"

  read -r -p "Continue with script? [y/N] " response
  if [[ "$response" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
    echo -e "OK. Running script..."
  else
    echo -e "OK. Exiting.\n"
    kill -s TERM $TOP_PID
  fi
}

#-----------------------------------------------------------------------#
# remove hidden directories as they likely contain unzip fragments

removeHiddenDirectories () {
  hidden=`find "$1" -type d -regextype posix-egrep -iregex ".+/\..+$"`
  if [ "$hidden" != "" ]; then
    echo -e "Hidden directories:"
    IFS=$'\n'; hiddendirs=("$hidden"); unset IFS
    for d in "${hiddendirs[@]}"; do
      echo -e "$d"
    done
    echo ""

    read -r -p "Remove hidden directories? [y/N] " response
    if [[ "$response" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
      for d in "${hiddendirs[@]}"; do
        echo -e "Deleting: $d"
        rm -r "$d"
      done
    fi
  fi
}

#-----------------------------------------------------------------------#
# make sure required software is installed

checkPreReq () {
  valid="true"

  if [ "$(type 'ffprobe' 2> /dev/null)" = "" ]; then
    echo -e "\nError: please install 'ffprobe' part of 'ffmpeg'!"
    valid="false"
  fi

  if [ "$(type 'ffmpeg' 2> /dev/null)" = "" ]; then
    echo -e "\nError: please install 'ffmpeg'!"
    valid="false"
  fi

  if [ "$valid" != "true" ]; then
    echo -e "Exiting.\n"
    kill -s TERM $TOP_PID
  fi
}

#-----------------------------------------------------------------------#
# validates artist: can only contain certain characters

validArtist () {
  match=`echo "$1" | grep -o "[^A-Za-z0-9,' &]\+"`
  if [ "$match" = "" ]; then echo "$1"; fi
}

#-----------------------------------------------------------------------#
# only audio files within a folder path (1 level at a time)

findAudio () {
  find "$1" -maxdepth 1 -type f  -regextype posix-egrep \
  -iregex ".+\.(mp3|flac|m4a|mp4|shn|wav)$" | sort
}

#-----------------------------------------------------------------------#
# album tag from audio file using ffprobe

id3Get () {
  ffprobe -loglevel error -show_entries format_tags="$1" \
  -of default=noprint_wrappers=1:nokey=1 "$2"
}

#-----------------------------------------------------------------------#

getBitrate () {
  ffprobe -v error -show_entries format=bit_rate "$1" | \
  grep -o "bit_rate=[0-9]\+" | sed -e "s/bit_rate=//"
}

#-----------------------------------------------------------------------#
# date helpers

parseDayMon () {
  echo "$1" | grep -o "^[0-9]\{1,2\}" | sed 's/^0*//' | xargs printf %02d
}

nextDate () {
  echo "$1" | sed -r "s/^[0-9]{1,4}[/.-]{1}//"
}

#-----------------------------------------------------------------------#
# $1=year $2=mon $3=day

isValidDate () {
  day=`echo "$3" | grep -o "^[0-9]\+"`
  vd="date --date=$year-$mon-$day +%s"
  vd=`$vd 2>&1 | grep -o "invalid date"`
  if [ "$vd" = "" ]; then echo "$1.$2.$3"; fi
}

#-----------------------------------------------------------------------#
# $1 = string to match
# $2 = prepend ie ^ (start of string)
# $3 = append ie $ (end of string)

matchDate () {
  # match: 2000.01.01 2000/1/1 2000-1-01
  # also match: 2000.01.01-03, 2000.01.01,03
  m0="[-,]\{0,1\}[0-9]\{0,2\}"

  match="$2[0-9]\{4\}[/.-]\{1\}[0-9]\{1,2\}[/.-]\{1\}[0-9]\{1,2\}$m0$m0$3"
  m1=`echo "$1" | grep -o "$match"`
  if [ "$m1" != "" ]; then
    year=`echo "$m1" | grep -o "^[0-9]\{4\}"`; m1=`nextDate "$m1"`
    mon=`parseDayMon "$m1"`; m1=`nextDate "$m1"`
    day=`echo "$m1" | grep -o "^[0-9]\{1,2\}$m0$m0" | sed -e "s/[^0-9]\+$//"`
  fi

  # match: 01.01.2000 1/1/2000 1-01-2000
  if [ "$m1" = "" ]; then
    match="$2[0-9]\{1,2\}[/.-]\{1\}[0-9]\{1,2\}[/.-]\{1\}[0-9]\{4\}$3"
    m1=`echo "$1" | grep -o "$match"`
    if [ "$m1" != "" ]; then
      mon=`parseDayMon "$m1"`; m1=`nextDate "$m1"`
      day=`parseDayMon "$m1"`; m1=`nextDate "$m1"`
      year=`echo "$m1" | grep -o "^[0-9]\{4\}"`
    fi
  fi

  # match: 03-30-69 06.09.73 and 98-08-23
  if [ "$m1" = "" ]; then
    match="$2[0-9]\{1,2\}[/.-]\{1\}[0-9]\{1,2\}[/.-]\{1\}[0-9]\{2\}$3"
    m1=`echo "$1" | grep -o "$match"`
    if [ "$m1" != "" ]; then
      x1=`parseDayMon "$m1"`; m1=`nextDate "$m1"`
      x2=`parseDayMon "$m1"`; m1=`nextDate "$m1"`
      x3=`parseDayMon "$m1"`

      if [ "$x1" -gt "12" ]; then
        # not month, must start with year
        year="$x1"; mon="$x2"; day="$x3"
      else
        mon="$x1"; day="$x2"; year="$x3"
      fi

      if [ "$year" -gt "50" ]; then
        year="19$year"
      else
        year="20$year"
      fi
    fi
  fi

  # validate date
  if [ "$m1" != "" ]; then
    vd=`isValidDate $year $mon $day`
    if [ "$vd" != "" ]; then
      album=`echo "$1" | sed -e "s/$match//g"`
      echo -e "$album\n$year\n$mon\n$day"
    fi
  fi
}

#-----------------------------------------------------------------------#

capitalizeStateCode () {
  codes="al ak as ar ca co ct de dc fl ga hi id il in ia ks ky la
  me md mh ma mi mn ms mo mt ne nv nh nj nm ny nc nd oh ok or pa ri sc
  sd tn tx ut vt va wa wv wi wy"

  # convert state code list into regexp match
  scR=`echo "\($codes\)" | sed -e ':a;N;$!ba;s/\n/ /g' \
  -e "s/\s\+/\\\\\\\|/ig"`

  echo "$1" | sed -e "s/, $scR\s/\U&/ig" -e "s/, $scR$/\U&/ig"
}

#-----------------------------------------------------------------------#
# if date matched, can update folder/tags
# $1 = artist
# $2 = album tag
# $3 = path w/o artist
# $4 = just parent directory of path

matchDateInAlbum () {
  # match with parent path
  m1=`matchDate "$4" "^"`

  # match with album tag
  if [ "$m1" = "" ]; then m1=`matchDate "$2"`; fi

  # match with full path
  if [ "$m1" = "" ]; then m1=`matchDate "$1/$3"`; fi

  if [ "$m1" != "" ]; then
    IFS=$'\n'; dates=($m1); unset IFS
    alb=`echo "${dates[0]}" | sed -e 's/^\///' -e 's/\/.*$//'`
  fi

  # match: studio album: starts with YEAR then space (only match in tag)
  if [ "$m1" = "" ]; then
    m1=`echo "$2" | grep -o "^[0-9]\{4\}\s\+"`
    if [ "$m1" != "" ]; then
      dates[0]=`echo "$m1" | sed -e 's/\s\+//g'`
    fi
  fi

  # return if did not match anything
  if [ "$m1" = "" ]; then echo ""; exit 1; fi

  # remove junk from beginning & end
  alb=`echo "$alb" | sed -e "s/^[^A-Za-z]\+//" -e "s/[^A-Za-z0-9\)]\+$//"`

  # replace ^$artist from within $alb
  alb=`echo "$alb" | sed -e "s/^$1//ig" -e "s/^[^A-Za-z]\+//"`

  # if $alb is blank, look to album tag, split before first -
  if [ "$alb" = "" ]; then
    if [ "$(echo $2 | grep -o '.\+ -')" != "" ]; then
      alb=`echo "$2" | grep -o ".\+ -" | sed -e "s/ -$//"`
    else
      alb="$2"
    fi
  fi

  # remove I, II, III, IV, V from beginning
  alb=`echo "$alb" | sed -e "s/^I*[IV]\+ //" -e "s/^[^A-Za-z]\+//"`

  # remove CD1, disc1, disc 1, cd 1 from end
  alb=`echo "$alb" | sed -e "s/[cC][dD]\s*[0-9]*//" \
  -e "s/[dD][iI][sS][cC]\s*[0-9]*//" -e "s/[^A-Za-z0-9\)]\+$//"`

  # replace any character not allowed with -
  alb=`echo "$alb" | sed -e "s/()//g" -e "s/\*//g" \
  -e "s/[^A-Za-z0-9 .,-&]\+/-/g"`

  # replace duplicate - & duplicate spaces
  alb=`echo "$alb" | sed -e "s/-\+/-/g" -e "s/\s\+/ /g"`

  # replace ', Ny' with ', NY'
  alb=`capitalizeStateCode "$alb"`

  # remove file extension from end
  alb=`echo "$alb" | sed -e 's/\(mp3\|flac\|m4a\|mp4\|shn\|wav\)$//i' \
  -e 's/[^A-Za-z0-9\)]\+$//'`
  
  # return in YEAR-MON-DAY format
  echo "${dates[1]}.${dates[2]}.${dates[3]} $alb"
}

#-----------------------------------------------------------------------#
# move path structure into NEEDS_WORK path

moveToUnknown() {
  echo -e "move: '$1' to: '$unknown'\n"
}

#-----------------------------------------------------------------------#
# $1 = path
# $2 = artist
# $3 = album

updateTags () {
  echo "album tag: update to: '$3'"
}

#-----------------------------------------------------------------------#
# $1 = path
# $2 = artist
# $3 = album

updatePath () {
  echo "path: update to: '$matchAlbum'"
}

#-----------------------------------------------------------------------#
# process sub-folders containing audio files
# $1 = $artist
# $2 = path w/o artist
# $3 = current index in directories

processDirectory () {
  IFS=$'\n'; files=(`findAudio "$rootPath/$1/$2"`); unset IFS
  if [ "${#files[@]}" -gt "0" ]; then

    # try: get embedded album tag from first audio file
    for f in "${files[@]}"; do
      albumTag=`id3Get "album" "$f"`
      break
    done

    # last directory name
    dirName=`echo "$2" | rev | sed -e "s/\/.\+//" | rev`

    # match date in tag & full path
    matchAlbum=`matchDateInAlbum "$1" "$albumTag" "$2" "$dirName"`
    if [ "$matchAlbum" != "" ]; then
      echo "${#files[@]} files: in '$2'"

      # check album tag
      if [ "$albumTag" = "$matchAlbum" ]; then
        echo "album tag: OK"
      else
        updateTags "$2" "$1" "$matchAlbum"
      fi

      # add audio file .ext to path if bitrate >320
      bitrate=`getBitrate "${files[0]}"`
      if [ "$bitrate" -gt "375000" ]; then
        # must be flac or better; include in album
        ext=`echo "${files[0]}" | grep -o "\.[A-Za-z0-9]\+$" | \
        sed -e "s/^\.//" -e "s/./\U&/ig"`
        matchAlbum="$matchAlbum - $ext"
      fi

      # check folder name
      if [ "$dirName" = "$matchAlbum" ]; then
        echo "path: OK"
      else
        updatePath "$2" "$1" "$matchAlbum"
      fi

      echo ""
    else
      moveToUnknown "$2"
    fi
  fi
}

#-----------------------------------------------------------------------#
# process root directory
# sets: $artist for each top level directory
# calls: processDirectory() for each $artist sub-directory

processIndex () {
  index="0"
  for p in "${paths[@]}"; do
    # trim $rootPath from path
    p=`echo "$p" | sed -r "s/^.{${#rootPath}}\///"`

    # skip $rootPath and $unknown directory
    if [ "$p" = "$unknown" -o "$p" = "$rootPath" ]; then
      index=$((index+1)); continue
    fi

    isSubDir=`echo "$p" | grep -o '.\+/.\+'`
    if [ "$isSubDir" = "" ]; then
      artist=`validArtist "$p"`
      if [ "$artist" != "" ]; then
        echo -e "\nArtist: $artist\n"
      else
        moveToUnknown "$p"
      fi
    else # subdirectory of $artist (comes after in sorted array)
      # make sure directory path still exists
      if [ -d "$rootPath/$p" ]; then
        # trim artist from path
        p=`echo "$p" | sed -r "s/^.{${#artist}}\///"`
        processDirectory "$artist" "$p" "$index"
      fi
    fi

    # increment index
    index=$((index+1))
  done
}

#-----------------------------------------------------------------------#
# main

if [ $# -ne 1 ]; then
  echo -e "\nUsage: emcc [path]\n"; exit 1
fi

if [ ! -d "$1" ]; then
  echo -e "\nError: '$1' not a directory\n"; exit 1
fi

rootPath="$1"

# move folders here that dont match the known pattern
unknown="000 NEEDS WORK"

checkPreReq
startupWarning
#removeHiddenDirectories "$rootPath"

IFS=$'\n'; paths=(`find "$rootPath" -type d | sort`); unset IFS
processIndex

echo -e "\nemcc finished. Exiting.\n"
