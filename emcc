#!/usr/bin/env bash

#-----------------------------------------------------------------------#
# to be able to exit entire program from within function

trap "exit 1" TERM
export TOP_PID=$$

#-----------------------------------------------------------------------#
# prints script name, warns about changes, prompts for input to continue

startupWarning () {
  echo -e "\nEvolving Music Collection Cleanup (emcc):"
  echo -e "Directory: $rootPath\n"
  echo -e "This script moves, renames, edits files within this directory.\n"

  read -r -p "Continue with script? [y/N] " response
  if [[ "$response" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
    echo -e "OK. Running script..."
  else
    echo -e "OK. Exiting.\n"
    kill -s TERM $TOP_PID
  fi
}

#-----------------------------------------------------------------------#
# remove hidden directories as they likely contain unzip fragments

removeHiddenDirectories () {
  hidden=`find "$1" -type d -regextype posix-egrep -iregex ".+/\..+$"`
  if [ "$hidden" != "" ]; then
    echo -e "Hidden directories:"
    IFS=$'\n'; hiddendirs=("$hidden"); unset IFS
    for d in "${hiddendirs[@]}"; do
      echo -e "$d"
    done
    echo ""

    read -r -p "Remove hidden directories? [y/N] " response
    if [[ "$response" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
      for d in "${hiddendirs[@]}"; do
        echo -e "Deleting: $d"
        rm -r "$d"
      done
    fi
  fi
}

#-----------------------------------------------------------------------#
# make sure required software is installed

checkPreReq () {
  valid="true"

  if [ "$(type 'ffprobe' 2> /dev/null)" = "" ]; then
    echo -e "\nError: please install 'ffprobe' part of 'ffmpeg'!"
    valid="false"
  fi

  if [ "$(type 'ffmpeg' 2> /dev/null)" = "" ]; then
    echo -e "\nError: please install 'ffmpeg'!"
    valid="false"
  fi

  if [ "$valid" != "true" ]; then
    echo -e "Exiting.\n"
    kill -s TERM $TOP_PID
  fi
}

#-----------------------------------------------------------------------#
# validates artist: can only contain certain characters

validArtist () {
  match=`echo "$1" | grep -o "[^A-Za-z0-9,' &]\+"`
  if [ "$match" = "" ]; then echo "$1"; fi
}

#-----------------------------------------------------------------------#
# only audio files within a folder path (1 level at a time)

findAudio () {
  find "$1" -maxdepth 1 -type f  -regextype posix-egrep \
  -iregex ".+\.(mp3|flac|m4a|mp4|shn|wav)$" | sort
}

#-----------------------------------------------------------------------#
# album tag from audio file using ffprobe

id3Get () {
  ffprobe -loglevel error -show_entries format_tags="$1" \
  -of default=noprint_wrappers=1:nokey=1 "$2" 2>&1
}

#-----------------------------------------------------------------------#

getBitrate () {
  ffprobe -v error -show_entries format=bit_rate "$1" 2>&1 | \
  grep -o "bit_rate=[0-9]\+" | sed -e "s/bit_rate=//"
}

#-----------------------------------------------------------------------#

getFileExt () {
  echo "$1" | grep -o "\.[A-Za-z0-9]\+$" | sed -e "s/^\.//" -e "s/./\U&/ig"
}

#-----------------------------------------------------------------------#
# date helpers

parseDayMon () {
  echo "$1" | grep -o "^[0-9]\{1,2\}" | sed 's/^0*//' | xargs printf %02d
}

nextDate () {
  echo "$1" | sed -r "s/^[0-9]{1,4}[/.-]{1}//"
}

#-----------------------------------------------------------------------#
# $1=year $2=mon $3=day

isValidDate () {
  day=`echo "$3" | grep -o "^[0-9]\+"`
  vd="date --date=$year-$mon-$day +%s"
  vd=`$vd 2>&1 | grep -o "invalid date"`
  if [ "$vd" = "" ]; then echo "$1.$2.$3"; fi
}

#-----------------------------------------------------------------------#
# $1 = string to match
# $2 = prepend ie ^ (start of string)
# $3 = append ie $ (end of string)

matchDate () {
  # match: 2000.01.01 2000/1/1 2000-1-01
  # also match: 2000.01.01-03, 2000.01.01,03
  m0="[-,]\{0,1\}[0-9]\{0,2\}"

  match="$2[0-9]\{4\}[/.-]\{1\}[0-9]\{1,2\}[/.-]\{1\}[0-9]\{1,2\}$m0$m0$3"
  m1=`echo "$1" | grep -o "$match"`
  if [ "$m1" != "" ]; then
    year=`echo "$m1" | grep -o "^[0-9]\{4\}"`; m1=`nextDate "$m1"`
    mon=`parseDayMon "$m1"`; m1=`nextDate "$m1"`
    day=`echo "$m1" | grep -o "^[0-9]\{1,2\}$m0$m0" | sed -e "s/[^0-9]\+$//"`
    if [ "${#day}" -eq "1" ]; then day="0$day"; fi
  fi

  # match: 01.01.2000 1/1/2000 1-01-2000
  if [ "$m1" = "" ]; then
    match="$2[0-9]\{1,2\}[/.-]\{1\}[0-9]\{1,2\}[/.-]\{1\}[0-9]\{4\}$3"
    m1=`echo "$1" | grep -o "$match"`
    if [ "$m1" != "" ]; then
      mon=`parseDayMon "$m1"`; m1=`nextDate "$m1"`
      day=`parseDayMon "$m1"`; m1=`nextDate "$m1"`
      year=`echo "$m1" | grep -o "^[0-9]\{4\}"`
    fi
  fi

  # match: 03-30-69 06.09.73 and 98-08-23
  if [ "$m1" = "" ]; then
    match="$2[0-9]\{1,2\}[/.-]\{1\}[0-9]\{1,2\}[/.-]\{1\}[0-9]\{2\}$3"
    m1=`echo "$1" | grep -o "$match"`
    if [ "$m1" != "" ]; then
      x1=`parseDayMon "$m1"`; m1=`nextDate "$m1"`
      x2=`parseDayMon "$m1"`; m1=`nextDate "$m1"`
      x3=`parseDayMon "$m1"`

      if [ "$x1" -gt "12" ]; then
        # not month, must start with year
        year="$x1"; mon="$x2"; day="$x3"
      else
        mon="$x1"; day="$x2"; year="$x3"
      fi

      if [ "$year" -gt "50" ]; then
        year="19$year"
      else
        year="20$year"
      fi
    fi
  fi

  # validate date
  if [ "$m1" != "" ]; then
    vd=`isValidDate $year $mon $day`
    if [ "$vd" != "" ]; then
      album=`echo "$1" | sed -e "s/$match//g"`
      echo -e "$album\n$year\n$mon\n$day"
    fi
  fi
}

#-----------------------------------------------------------------------#

capitalizeStateCode () {
  codes="al ak as ar ca co ct de dc fl ga hi id il in ia ks ky la
  me md mh ma mi mn ms mo mt ne nv nh nj nm ny nc nd oh ok or pa ri sc
  sd tn tx ut vt va wa wv wi wy"

  # convert state code list into regexp match
  scR=`echo "\($codes\)" | sed -e ':a;N;$!ba;s/\n/ /g' \
  -e "s/\s\+/\\\\\\\|/ig"`

  echo "$1" | sed -e "s/, $scR\s/\U&/ig" -e "s/, $scR$/\U&/ig"
}

#-----------------------------------------------------------------------#
# album is a full path - work from end of path to root
# make sure we have enough chars; avoid returning only 'CD1' or 'Disc1'

albumFromPath () {
  if [ "$(echo $1 | grep -o '\/')" != "" ]; then
    last=`echo "$1" | rev | sed -e 's/\/.*$//' | rev`
    if [ "${#last}" -lt "10" ]; then
      last2=`echo "$1" | sed -e "s/\/$last$//" | rev | \
      sed -e 's/\/.*$//' | rev | sed -e 's/^[0-9]\+\s\+//'`
      # combine parent and grandparent directories into album name
      echo "$last2 $last"
    else
      echo "$last" # album is just parent directory name
    fi
  else
    echo "$1" # pass back what was passed in
  fi
}

#-----------------------------------------------------------------------#
# $1 = album tag
# $2 = just parent directory of path

matchStudioAlbum () {
  # try album tag
  m1=`echo "$1" | grep -o "^[0-9]\{4\}\s\+"`

  # try folder name
  if [ "$m1" = "" ]; then
    m2="$2"; m1=`echo "$2" | grep -o "^[0-9]\{4\}\s\+"`
  else
    m2="$1"
  fi

  if [ "$m1" != "" ]; then
    # remainder becomes album name
    alb=`echo "$m2" | sed -e 's/^[0-9]\+\s\+//g'`

    # to avoid too many mistaken matches from folder name:
    # folder name & album tag have to be somewhat similar
    if [[ $2 == *"$1"* ]]; then
      m1=`echo "$m1" | grep -o "[0-9]\+"`
      echo -e "$alb\n$m1"
    fi
  fi
}

#-----------------------------------------------------------------------#
# match disc number in album
# $1 = album string; $2 = match(0) or replace(1)

matchDisc () {
  if [ "$2" = "" -o "$2" = "0" ]; then
    echo "$1 : $2" >/tmp/emcc
    echo $1 | grep -io "\s\+\(cd\|disc\)\s*[0-9]\+" | grep -o "[0-9]\+$"
  elif [ "$2" = "1" ]; then
    echo $1 | sed -e "s/\s\+\(cd\|disc\)\s*[0-9]\+//i" \
    -e "s/[^A-Za-z0-9\)]\+$//"
  fi
}

#-----------------------------------------------------------------------#
# match roman numerals in album
# $1 = album string; $2 = match(0) or replace(1)
# have to parse discnumber as file sort order is reversed

matchRnSet () {
  if [ "$2" = "" -o "$2" = "0" ]; then
    rn=`echo "$1" | grep -o "^I*[IV]\+ " | sed -e "s/\s\+$//"`
    if [ "$rn" != "" ]; then
      case "$rn" in
      "I") echo "1" ;;
      "II") echo "2" ;;
      "III") echo "3" ;;
      "IV") echo "4" ;;
      "V") echo "5"
      esac
    fi
  elif [ "$2" = "1" ]; then
    echo "$1" | sed -e "s/^I*[IV]\+ //" -e "s/^[^A-Za-z]\+//"
  fi
}

#-----------------------------------------------------------------------#
# remove characters not allowed

replaceNA () {
  echo "$1" | sed -e "s/(\s*)//g" -e 's/\]//g' -e 's/\[//g' \
  -e 's/[\*\!\:\*\$\?\/\"\;\{\}]//g' -e "s/[^A-Za-z0-9 .,-&]\+/-/g"
}

#-----------------------------------------------------------------------#
# remove junk from beginning & end

trimEnds () {
  echo "$1" | sed -e "s/^[^A-Za-z]\+//" -e "s/[^A-Za-z0-9\)]\+$//"
}

#-----------------------------------------------------------------------#
# after artist has been removed
# $1 = album

formatAlbum () {
  # replace any character not allowed
  alb=`replaceNA "$alb"`; alb=`trimEnds "$alb"`

  # reset disc; replace @ before we use as disc number identifier
  disc=""; alb=`echo "$1" | sed -e 's/\@//g'`

  # remove I, II, III, IV, V from beginning
  rn=`matchRnSet "$alb"`
  if [ "$rn" != "" ]; then disc=" @$rn"; alb=`matchRnSet "$alb" "1"`; fi

  # remove CD1, disc1, disc 1, cd 1
  dn=`matchDisc "$alb"`
  if [ "$dn" != "" ]; then disc=" @$dn"; alb=`matchDisc "$alb" "1"`; fi

  # replace ', Ny' with ', NY'
  alb=`capitalizeStateCode "$alb"`

  # replace duplicate - & duplicate spaces
  alb=`echo "$alb" | sed -e "s/-\s*-/-/g" -e "s/-\+/-/g" -e "s/\s\+/ /g"`

  # if ends in space then a single digit, digit is probably discnumber
  dn2=`echo "$alb" | grep -o "\s\+[0-9]$" | grep -o "[0-9]$"`
  if [ "$dn2" != "" ]; then
    disc=" @$dn2"
    alb=`echo "$alb" | sed -e "s/\s\+[0-9]$//"`
  fi

  # remove bitrate from end
  alb=`echo "$alb" | sed -e 's/\s\+\(128\|192\|256\|320\)$//'`
  alb=`trimEnds "$alb"`

  # remove file extension from end
  alb=`echo "$alb" | sed -e 's/\(mp3\|flac\|m4a\|mp4\|shn\|wav\)$//i'`
  alb=`trimEnds "$alb"`

  # remove SBD from end
  alb=`echo "$alb" | sed -e 's/sbd$//i'`; alb=`trimEnds "$alb"`
  
  echo "$alb$disc"
}

#-----------------------------------------------------------------------#
# if date matched, can update folder/tags
# $1 = artist
# $2 = album tag
# $3 = path w/o artist
# $4 = just parent directory of path

matchDateInAlbum () {
  # match: live album: with parent path
  m1=`matchDate "$4" "^"`

  # match: live album: with album tag
  if [ "$m1" = "" ]; then m1=`matchDate "$2"`; fi

  # match: live album: with full path
  if [ "$m1" = "" ]; then m1=`matchDate "$1/$3"`; fi

  # match: studio album: starts with YEAR then space
  if [ "$m1" = "" ]; then m1=`matchStudioAlbum "$2" "$4"`; fi

  # split info from $m1 data
  if [ "$m1" != "" ]; then
    IFS=$'\n'; dates=($m1); unset IFS

    alb=`albumFromPath "${dates[0]}"`

    # replace any character not allowed
    alb=`replaceNA "$alb"`; alb=`trimEnds "$alb"`

    # replace ^$artist from within $alb
    alb=`echo "$alb" | sed -e "s/^$1//ig"`; alb=`trimEnds "$alb"`

    # if $alb is blank, look to album tag, split before first -
    if [ "$alb" = "" ]; then
      if [ "$(echo $2 | grep -o '.\+ -')" != "" ]; then
        alb=`echo "$2" | grep -o ".\+ -" | sed -e "s/ -$//"`
      else
        alb="$2"
      fi
    fi

    # format the album
    alb=`formatAlbum "$alb"`

    if [ "${dates[2]}" = "" ]; then
      # only have YEAR
      echo "${dates[1]} $alb"
    else
      # return in YEAR-MON-DAY format
      echo "${dates[1]}.${dates[2]}.${dates[3]} $alb"
    fi
  fi
}

#-----------------------------------------------------------------------#
# $1 = path
# $2 = artist
# $3 = album
# $4 = discnumber

updateTags () {
  if [ "$4" != "" ]; then echo "discnumber: $4"; fi
  echo "album tag: update to: '$3'"
}

#-----------------------------------------------------------------------#
# $1 = path
# $2 = artist
# $3 = album

updatePath () {
  echo "path: update to: '$matchAlbum'"
}

#-----------------------------------------------------------------------#
# move path structure into NEEDS_WORK path

moveToUnknown() {
  echo -e "move: '$1' to: '$unknown'\n"
}

#-----------------------------------------------------------------------#
# process sub-folders containing audio files
# $1 = $artist
# $2 = path w/o artist
# $3 = current index in directories

processDirectory () {
  IFS=$'\n'; files=(`findAudio "$rootPath/$1/$2"`); unset IFS
  if [ "${#files[@]}" -gt "0" ]; then

    # try: get embedded album tag from first audio file
    for f in "${files[@]}"; do
      albumTag=`id3Get "album" "$f"`
      break
    done

    # last directory name
    dirName=`echo "$2" | rev | sed -e "s/\/.\+//" | rev`

    # match date in tag & full path
    matchAlbum=`matchDateInAlbum "$1" "$albumTag" "$2" "$dirName"`
    if [ "$matchAlbum" != "" ]; then
      echo "${#files[@]} files: in '$2'"

      # pull disc number (if found)
      disc=`echo "$matchAlbum" | grep -o " \@[0-9]\+$" | sed -e "s/ \@//"`
      if [ "$disc" != "" ]; then
        matchAlbum=`echo "$matchAlbum" | sed -e "s/\s\+\@[0-9]\+$//"`
      fi

      # check album tag
      if [ "$albumTag" = "$matchAlbum" ]; then
        echo "album tag: OK"
      else
        updateTags "$2" "$1" "$matchAlbum" "$disc"
      fi

      # add audio file .ext to path if bitrate >320
      bitrate=`getBitrate "${files[0]}"`
      if [ "$bitrate" = "" ]; then
        echo "Error: invalid/missing files"
      else
        if [ "$bitrate" -gt "400000" ]; then
          # must be flac or better; include in album
          ext=`getFileExt "${files[0]}"`
          matchAlbum="$matchAlbum - $ext"
        fi
      fi

      # check folder name
      if [ "$dirName" = "$matchAlbum" ]; then
        echo "path: OK"
      else
        updatePath "$2" "$1" "$matchAlbum"
      fi

      echo ""
    else
      moveToUnknown "$2"
    fi
  fi
}

#-----------------------------------------------------------------------#
# process root directory
# sets: $artist for each top level directory
# calls: processDirectory() for each $artist sub-directory

processIndex () {
  index="0"
  for p in "${paths[@]}"; do
    # trim $rootPath from path
    p=`echo "$p" | sed -r "s/^.{${#rootPath}}\///"`

    # skip $rootPath and $unknown directory
    if [ "$p" = "$unknown" -o "$p" = "$rootPath" ]; then
      index=$((index+1)); continue
    fi

    isSubDir=`echo "$p" | grep -o '.\+/.\+'`
    if [ "$isSubDir" = "" ]; then
      artist=`validArtist "$p"`
      if [ "$artist" != "" ]; then
        echo -e "\nArtist: $artist\n"
      else
        moveToUnknown "$p"
      fi
    else # subdirectory of $artist (comes after in sorted array)
      # make sure directory path still exists
      if [ -d "$rootPath/$p" ]; then
        # trim artist from path
        p=`echo "$p" | sed -r "s/^.{${#artist}}\///"`
        processDirectory "$artist" "$p" "$index"
      fi
    fi

    # increment index
    index=$((index+1))
  done
}

#-----------------------------------------------------------------------#
# main

if [ $# -ne 1 ]; then
  echo -e "\nUsage: emcc [path]\n"; exit 1
fi

if [ ! -d "$1" ]; then
  echo -e "\nError: '$1' not a directory\n"; exit 1
fi

rootPath="$1"

# move folders here that dont match the known pattern
unknown="000 NEEDS WORK"

checkPreReq
startupWarning
#removeHiddenDirectories "$rootPath"

IFS=$'\n'; paths=(`find "$rootPath" -type d | sort`); unset IFS
processIndex

echo -e "\nemcc finished. Exiting.\n"
